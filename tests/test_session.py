"""Tests for session management.

Covers: REQ-D02 (access control)

Tests for:
- Session creation and validation
- Session expiration
- Session revocation (single and all)
- Session refresh tokens
- Multi-device session support
- Authentication middleware
"""

from datetime import UTC, datetime, timedelta
from unittest.mock import AsyncMock, MagicMock
from uuid import uuid4

import pytest

from qerds.api.middleware.auth import (
    AuthenticatedUser,
    get_current_user,
    set_current_user,
)
from qerds.services.session import (
    DeviceInfo,
    SessionError,
    SessionExpiredError,
    SessionInfo,
    SessionNotFoundError,
    SessionRevokedError,
    SessionService,
    SessionToken,
)

# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------


@pytest.fixture
def mock_db_session():
    """Create a mock async database session."""
    session = AsyncMock()
    session.add = MagicMock()
    session.flush = AsyncMock()
    session.execute = AsyncMock()
    return session


@pytest.fixture
def session_service(mock_db_session):
    """Create a SessionService instance with mock database."""
    return SessionService(mock_db_session)


@pytest.fixture
def admin_user_id():
    """Generate a test admin user ID."""
    return uuid4()


@pytest.fixture
def api_client_id():
    """Generate a test API client ID."""
    return uuid4()


@pytest.fixture
def party_id():
    """Generate a test party ID."""
    return uuid4()


@pytest.fixture
def device_info():
    """Create test device information."""
    return DeviceInfo(
        ip_address="192.168.1.100",
        user_agent="Mozilla/5.0 (Test)",
        device_id="test-device-001",
        geo_country="FR",
        geo_city="Paris",
    )


# ---------------------------------------------------------------------------
# SessionService Tests
# ---------------------------------------------------------------------------


class TestSessionCreation:
    """Tests for session creation."""

    @pytest.mark.asyncio
    async def test_create_session_for_admin_user(
        self, session_service, mock_db_session, admin_user_id
    ):
        """Test creating a session for an admin user."""
        token = await session_service.create_session(admin_user_id=admin_user_id)

        assert token is not None
        assert isinstance(token, SessionToken)
        # session_id is generated by the ORM model and may be None in mocked tests
        # (depends on server_default behavior in testing context)
        assert token.access_token is not None
        assert token.refresh_token is not None
        assert token.expires_at > datetime.now(UTC)
        assert token.refresh_expires_at > token.expires_at

        # Verify session was added to database
        mock_db_session.add.assert_called_once()
        mock_db_session.flush.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_session_for_api_client(
        self, session_service, mock_db_session, api_client_id
    ):
        """Test creating a session for an API client."""
        token = await session_service.create_session(api_client_id=api_client_id)

        assert token is not None
        assert token.access_token is not None
        mock_db_session.add.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_session_for_party(self, session_service, mock_db_session, party_id):
        """Test creating a session for a party (sender/recipient)."""
        token = await session_service.create_session(party_id=party_id)

        assert token is not None
        assert token.access_token is not None
        mock_db_session.add.assert_called_once()

    @pytest.mark.asyncio
    async def test_create_session_with_device_info(
        self, session_service, mock_db_session, admin_user_id, device_info
    ):
        """Test creating a session with device information."""
        token = await session_service.create_session(
            admin_user_id=admin_user_id,
            device_info=device_info,
        )

        assert token is not None
        # Verify the session record was created with device info
        mock_db_session.add.assert_called_once()
        session_record = mock_db_session.add.call_args[0][0]
        assert session_record.ip_address == device_info.ip_address
        assert session_record.user_agent == device_info.user_agent
        assert session_record.device_id == device_info.device_id
        assert session_record.geo_country == device_info.geo_country
        assert session_record.geo_city == device_info.geo_city

    @pytest.mark.asyncio
    async def test_create_session_without_refresh_token(
        self, session_service, mock_db_session, admin_user_id
    ):
        """Test creating a session without refresh token."""
        token = await session_service.create_session(
            admin_user_id=admin_user_id,
            include_refresh_token=False,
        )

        assert token is not None
        assert token.access_token is not None
        assert token.refresh_token is None
        assert token.refresh_expires_at is None

    @pytest.mark.asyncio
    async def test_create_session_with_metadata(
        self, session_service, mock_db_session, admin_user_id
    ):
        """Test creating a session with custom metadata."""
        metadata = {"mfa_used": True, "login_method": "password"}
        token = await session_service.create_session(
            admin_user_id=admin_user_id,
            session_metadata=metadata,
        )

        assert token is not None
        session_record = mock_db_session.add.call_args[0][0]
        assert session_record.session_metadata == metadata

    @pytest.mark.asyncio
    async def test_create_session_requires_principal(self, session_service):
        """Test that session creation requires exactly one principal ID."""
        with pytest.raises(ValueError, match="Exactly one of"):
            await session_service.create_session()

    @pytest.mark.asyncio
    async def test_create_session_rejects_multiple_principals(
        self, session_service, admin_user_id, api_client_id
    ):
        """Test that session creation rejects multiple principal IDs."""
        with pytest.raises(ValueError, match="Exactly one of"):
            await session_service.create_session(
                admin_user_id=admin_user_id,
                api_client_id=api_client_id,
            )


class TestSessionValidation:
    """Tests for session validation."""

    @pytest.mark.asyncio
    async def test_validate_valid_session(self, session_service, mock_db_session):
        """Test validating a valid session token."""
        # Create a mock session record
        mock_session = MagicMock()
        mock_session.is_active = True
        mock_session.is_expired = False
        mock_session.is_revoked = False
        mock_session.session_id = uuid4()

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_session
        mock_db_session.execute.return_value = mock_result

        session = await session_service.validate_session("test-token")

        assert session is not None
        assert session == mock_session
        # Activity should be updated by default
        assert mock_db_session.execute.call_count == 2  # select + update

    @pytest.mark.asyncio
    async def test_validate_session_without_activity_update(self, session_service, mock_db_session):
        """Test validating a session without updating activity."""
        mock_session = MagicMock()
        mock_session.is_active = True
        mock_session.is_expired = False
        mock_session.is_revoked = False

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_session
        mock_db_session.execute.return_value = mock_result

        session = await session_service.validate_session("test-token", update_activity=False)

        assert session is not None
        # Should only execute select, not update
        assert mock_db_session.execute.call_count == 1

    @pytest.mark.asyncio
    async def test_validate_nonexistent_session(self, session_service, mock_db_session):
        """Test validating a nonexistent session token."""
        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = None
        mock_db_session.execute.return_value = mock_result

        session = await session_service.validate_session("invalid-token")

        assert session is None

    @pytest.mark.asyncio
    async def test_validate_inactive_session(self, session_service, mock_db_session):
        """Test validating an inactive session."""
        mock_session = MagicMock()
        mock_session.is_active = False

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_session
        mock_db_session.execute.return_value = mock_result

        session = await session_service.validate_session("test-token")

        assert session is None

    @pytest.mark.asyncio
    async def test_validate_expired_session(self, session_service, mock_db_session):
        """Test validating an expired session."""
        mock_session = MagicMock()
        mock_session.is_active = True
        mock_session.is_expired = True

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_session
        mock_db_session.execute.return_value = mock_result

        session = await session_service.validate_session("test-token")

        assert session is None

    @pytest.mark.asyncio
    async def test_validate_revoked_session(self, session_service, mock_db_session):
        """Test validating a revoked session."""
        mock_session = MagicMock()
        mock_session.is_active = True
        mock_session.is_expired = False
        mock_session.is_revoked = True

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_session
        mock_db_session.execute.return_value = mock_result

        session = await session_service.validate_session("test-token")

        assert session is None


class TestSessionRevocation:
    """Tests for session revocation."""

    @pytest.mark.asyncio
    async def test_revoke_session(self, session_service, mock_db_session):
        """Test revoking a specific session."""
        session_id = uuid4()
        revoked_by = uuid4()

        mock_result = MagicMock()
        mock_result.rowcount = 1
        mock_db_session.execute.return_value = mock_result

        result = await session_service.revoke_session(
            session_id, revoked_by=revoked_by, reason="User logged out"
        )

        assert result is True
        mock_db_session.execute.assert_called_once()

    @pytest.mark.asyncio
    async def test_revoke_nonexistent_session(self, session_service, mock_db_session):
        """Test revoking a session that doesn't exist."""
        session_id = uuid4()

        mock_result = MagicMock()
        mock_result.rowcount = 0
        mock_db_session.execute.return_value = mock_result

        result = await session_service.revoke_session(session_id)

        assert result is False

    @pytest.mark.asyncio
    async def test_revoke_all_user_sessions(self, session_service, mock_db_session, admin_user_id):
        """Test revoking all sessions for a user."""
        revoked_by = uuid4()

        mock_result = MagicMock()
        mock_result.rowcount = 5
        mock_db_session.execute.return_value = mock_result

        count = await session_service.revoke_all_user_sessions(
            admin_user_id=admin_user_id,
            revoked_by=revoked_by,
            reason="Security incident",
        )

        assert count == 5
        mock_db_session.execute.assert_called_once()

    @pytest.mark.asyncio
    async def test_revoke_all_sessions_except_current(
        self, session_service, mock_db_session, admin_user_id
    ):
        """Test revoking all sessions except the current one."""
        current_session_id = uuid4()
        revoked_by = uuid4()

        mock_result = MagicMock()
        mock_result.rowcount = 4
        mock_db_session.execute.return_value = mock_result

        count = await session_service.revoke_all_user_sessions(
            admin_user_id=admin_user_id,
            revoked_by=revoked_by,
            exclude_session_id=current_session_id,
        )

        assert count == 4

    @pytest.mark.asyncio
    async def test_revoke_all_sessions_requires_principal(self, session_service):
        """Test that revoking all sessions requires exactly one principal ID."""
        with pytest.raises(ValueError, match="Exactly one of"):
            await session_service.revoke_all_user_sessions()


class TestSessionRefresh:
    """Tests for session refresh."""

    @pytest.mark.asyncio
    async def test_refresh_session(self, session_service, mock_db_session):
        """Test refreshing a session with a refresh token."""
        mock_session = MagicMock()
        mock_session.session_id = uuid4()
        mock_session.is_revoked = False
        mock_session.refresh_expires_at = datetime.now(UTC) + timedelta(days=7)

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_session
        mock_db_session.execute.return_value = mock_result

        new_token = await session_service.refresh_session("refresh-token")

        assert new_token is not None
        assert new_token.session_id == mock_session.session_id
        assert new_token.access_token is not None
        assert new_token.refresh_token is not None
        assert new_token.expires_at > datetime.now(UTC)

    @pytest.mark.asyncio
    async def test_refresh_nonexistent_session(self, session_service, mock_db_session):
        """Test refreshing with an invalid refresh token."""
        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = None
        mock_db_session.execute.return_value = mock_result

        with pytest.raises(SessionNotFoundError):
            await session_service.refresh_session("invalid-refresh-token")

    @pytest.mark.asyncio
    async def test_refresh_revoked_session(self, session_service, mock_db_session):
        """Test refreshing a revoked session."""
        mock_session = MagicMock()
        mock_session.is_revoked = True

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_session
        mock_db_session.execute.return_value = mock_result

        with pytest.raises(SessionRevokedError):
            await session_service.refresh_session("refresh-token")

    @pytest.mark.asyncio
    async def test_refresh_expired_session(self, session_service, mock_db_session):
        """Test refreshing an expired refresh token."""
        mock_session = MagicMock()
        mock_session.is_revoked = False
        mock_session.refresh_expires_at = datetime.now(UTC) - timedelta(days=1)

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_session
        mock_db_session.execute.return_value = mock_result

        with pytest.raises(SessionExpiredError):
            await session_service.refresh_session("refresh-token")


class TestSessionRetrieval:
    """Tests for session retrieval operations."""

    @pytest.mark.asyncio
    async def test_get_session_by_id(self, session_service, mock_db_session):
        """Test retrieving a session by ID."""
        session_id = uuid4()
        mock_session = MagicMock()
        mock_session.session_id = session_id

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_session
        mock_db_session.execute.return_value = mock_result

        session = await session_service.get_session(session_id)

        assert session is not None
        assert session.session_id == session_id

    @pytest.mark.asyncio
    async def test_get_nonexistent_session(self, session_service, mock_db_session):
        """Test retrieving a nonexistent session."""
        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = None
        mock_db_session.execute.return_value = mock_result

        session = await session_service.get_session(uuid4())

        assert session is None

    @pytest.mark.asyncio
    async def test_get_user_sessions(self, session_service, mock_db_session, admin_user_id):
        """Test retrieving all sessions for a user."""
        # Create mock sessions
        mock_sessions = []
        for i in range(3):
            s = MagicMock()
            s.session_id = uuid4()
            s.session_type = "admin"
            s.get_principal_id.return_value = admin_user_id
            s.get_principal_type.return_value = "admin_user"
            s.created_at = datetime.now(UTC) - timedelta(hours=i)
            s.expires_at = datetime.now(UTC) + timedelta(hours=24 - i)
            s.last_activity_at = datetime.now(UTC) - timedelta(minutes=i * 10)
            s.ip_address = f"192.168.1.{100 + i}"
            s.user_agent = "Test Agent"
            s.is_valid = True
            mock_sessions.append(s)

        mock_result = MagicMock()
        mock_result.scalars.return_value.all.return_value = mock_sessions
        mock_db_session.execute.return_value = mock_result

        sessions = await session_service.get_user_sessions(admin_user_id=admin_user_id)

        assert len(sessions) == 3
        assert all(isinstance(s, SessionInfo) for s in sessions)

    @pytest.mark.asyncio
    async def test_get_user_sessions_empty(self, session_service, mock_db_session):
        """Test retrieving sessions for a user with no sessions."""
        sessions = await session_service.get_user_sessions()

        assert sessions == []


class TestSessionCleanup:
    """Tests for session cleanup operations."""

    @pytest.mark.asyncio
    async def test_cleanup_expired_sessions(self, session_service, mock_db_session):
        """Test cleaning up old expired sessions."""
        mock_result = MagicMock()
        mock_result.rowcount = 10
        mock_db_session.execute.return_value = mock_result

        count = await session_service.cleanup_expired_sessions(older_than_days=30)

        assert count == 10
        mock_db_session.execute.assert_called_once()


class TestTokenSecurity:
    """Tests for token security features."""

    def test_token_generation_unique(self, session_service):
        """Test that generated tokens are unique."""
        tokens = [session_service._generate_token() for _ in range(100)]
        assert len(tokens) == len(set(tokens))

    def test_token_hash_consistent(self, session_service):
        """Test that token hashing is consistent."""
        token = "test-token-12345"
        hash1 = session_service._hash_token(token)
        hash2 = session_service._hash_token(token)
        assert hash1 == hash2

    def test_token_hash_length(self, session_service):
        """Test that token hash is SHA-256 (64 hex chars)."""
        token = "test-token"
        hash_value = session_service._hash_token(token)
        assert len(hash_value) == 64

    def test_different_tokens_different_hashes(self, session_service):
        """Test that different tokens produce different hashes."""
        hash1 = session_service._hash_token("token1")
        hash2 = session_service._hash_token("token2")
        assert hash1 != hash2


# ---------------------------------------------------------------------------
# AuthenticatedUser Tests
# ---------------------------------------------------------------------------


class TestAuthenticatedUser:
    """Tests for AuthenticatedUser dataclass."""

    def test_has_permission(self):
        """Test permission checking."""
        user = AuthenticatedUser(
            principal_id=uuid4(),
            principal_type="admin_user",
            permissions=frozenset(["view_deliveries", "create_delivery"]),
        )

        assert user.has_permission("view_deliveries") is True
        assert user.has_permission("delete_delivery") is False

    def test_has_permission_superuser(self):
        """Test that superusers have all permissions."""
        user = AuthenticatedUser(
            principal_id=uuid4(),
            principal_type="admin_user",
            is_superuser=True,
            permissions=frozenset(),
        )

        assert user.has_permission("any_permission") is True
        assert user.has_permission("another_permission") is True

    def test_has_role(self):
        """Test role checking."""
        user = AuthenticatedUser(
            principal_id=uuid4(),
            principal_type="admin_user",
            roles=frozenset(["admin", "auditor"]),
        )

        assert user.has_role("admin") is True
        assert user.has_role("auditor") is True
        assert user.has_role("superuser") is False

    def test_to_principal(self):
        """Test conversion to authz Principal."""
        user_id = uuid4()
        user = AuthenticatedUser(
            principal_id=user_id,
            principal_type="admin_user",
            roles=frozenset(["admin"]),
            permissions=frozenset(["view_users"]),
            is_superuser=True,
            is_active=True,
            ip_address="192.168.1.1",
            user_agent="Test Agent",
        )

        principal = user.to_principal()

        assert principal.principal_id == user_id
        assert principal.principal_type == "admin_user"
        assert principal.is_superuser is True
        assert principal.is_active is True
        assert "admin" in principal.roles
        assert "view_users" in principal.explicit_permissions


# ---------------------------------------------------------------------------
# Current User Context Tests
# ---------------------------------------------------------------------------


class TestCurrentUserContext:
    """Tests for current user context management."""

    def test_set_and_get_current_user(self):
        """Test setting and getting the current user."""
        user = AuthenticatedUser(
            principal_id=uuid4(),
            principal_type="admin_user",
        )

        set_current_user(user)
        retrieved = get_current_user()

        assert retrieved is user

    def test_clear_current_user(self):
        """Test clearing the current user."""
        user = AuthenticatedUser(
            principal_id=uuid4(),
            principal_type="admin_user",
        )

        set_current_user(user)
        set_current_user(None)

        assert get_current_user() is None

    def test_default_current_user_is_none(self):
        """Test that default current user is None."""
        # Reset context
        set_current_user(None)
        assert get_current_user() is None


# ---------------------------------------------------------------------------
# DeviceInfo Tests
# ---------------------------------------------------------------------------


class TestDeviceInfo:
    """Tests for DeviceInfo dataclass."""

    def test_device_info_defaults(self):
        """Test DeviceInfo default values."""
        info = DeviceInfo()
        assert info.ip_address is None
        assert info.user_agent is None
        assert info.device_id is None
        assert info.geo_country is None
        assert info.geo_city is None

    def test_device_info_with_values(self):
        """Test DeviceInfo with specified values."""
        info = DeviceInfo(
            ip_address="10.0.0.1",
            user_agent="Custom Agent",
            device_id="device-123",
            geo_country="US",
            geo_city="New York",
        )
        assert info.ip_address == "10.0.0.1"
        assert info.user_agent == "Custom Agent"
        assert info.device_id == "device-123"
        assert info.geo_country == "US"
        assert info.geo_city == "New York"


# ---------------------------------------------------------------------------
# SessionInfo Tests
# ---------------------------------------------------------------------------


class TestSessionInfo:
    """Tests for SessionInfo dataclass."""

    def test_session_info_creation(self):
        """Test SessionInfo creation."""
        session_id = uuid4()
        principal_id = uuid4()
        now = datetime.now(UTC)

        info = SessionInfo(
            session_id=session_id,
            session_type="admin",
            principal_id=principal_id,
            principal_type="admin_user",
            created_at=now,
            expires_at=now + timedelta(hours=24),
            last_activity_at=now,
            ip_address="192.168.1.1",
            user_agent="Test Agent",
            is_active=True,
            is_current=True,
        )

        assert info.session_id == session_id
        assert info.principal_id == principal_id
        assert info.is_current is True


# ---------------------------------------------------------------------------
# SessionToken Tests
# ---------------------------------------------------------------------------


class TestSessionToken:
    """Tests for SessionToken dataclass."""

    def test_session_token_creation(self):
        """Test SessionToken creation."""
        session_id = uuid4()
        now = datetime.now(UTC)

        test_access_token = "access-token-abc"
        test_refresh_token = "refresh-token-xyz"
        token = SessionToken(
            session_id=session_id,
            access_token=test_access_token,
            refresh_token=test_refresh_token,
            expires_at=now + timedelta(hours=24),
            refresh_expires_at=now + timedelta(days=7),
        )

        assert token.session_id == session_id
        assert token.access_token == test_access_token
        assert token.refresh_token == test_refresh_token

    def test_session_token_without_refresh(self):
        """Test SessionToken without refresh token."""
        session_id = uuid4()
        now = datetime.now(UTC)

        test_access_token = "access-token-abc"
        token = SessionToken(
            session_id=session_id,
            access_token=test_access_token,
            refresh_token=None,
            expires_at=now + timedelta(hours=24),
            refresh_expires_at=None,
        )

        assert token.refresh_token is None
        assert token.refresh_expires_at is None


# ---------------------------------------------------------------------------
# Exception Tests
# ---------------------------------------------------------------------------


class TestSessionExceptions:
    """Tests for session-related exceptions."""

    def test_session_error_base(self):
        """Test SessionError base exception."""
        error = SessionError("Generic session error")
        assert str(error) == "Generic session error"

    def test_session_not_found_error(self):
        """Test SessionNotFoundError exception."""
        error = SessionNotFoundError("Session not found")
        assert isinstance(error, SessionError)

    def test_session_expired_error(self):
        """Test SessionExpiredError exception."""
        error = SessionExpiredError("Session expired")
        assert isinstance(error, SessionError)

    def test_session_revoked_error(self):
        """Test SessionRevokedError exception."""
        error = SessionRevokedError("Session revoked")
        assert isinstance(error, SessionError)
