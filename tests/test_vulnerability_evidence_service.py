"""Tests for the Vulnerability Evidence Service.

Tests cover:
- Storing vulnerability scan reports (REQ-D05)
- Storing penetration test reports (REQ-D06)
- Storing SBOMs (REQ-H09)
- Storing remediation tracking artifacts
- Listing and filtering artifacts
- Downloading artifacts
- Updating remediation status
- Error handling

Run with: docker compose exec qerds-api pytest tests/test_vulnerability_evidence_service.py -v
"""

from __future__ import annotations

import uuid
from datetime import UTC, datetime, timedelta
from unittest.mock import AsyncMock, MagicMock

import pytest

from qerds.db.models.audit import SBOMFormat, ScanOutputFormat, VulnArtifactType
from qerds.services.vulnerability_evidence import (
    ArtifactNotFoundError,
    InvalidArtifactError,
    PentestMetadata,
    VulnerabilityEvidenceConfig,
    VulnerabilityEvidenceService,
    VulnScanMetadata,
    create_vulnerability_evidence_service,
)

# -----------------------------------------------------------------------------
# Test Fixtures
# -----------------------------------------------------------------------------


@pytest.fixture
def mock_db_session():
    """Create a mock database session."""
    session = AsyncMock()
    session.add = MagicMock()
    session.flush = AsyncMock()
    session.execute = AsyncMock()
    return session


@pytest.fixture
def mock_object_store():
    """Create a mock object store client."""
    object_store = MagicMock()
    object_store.ensure_bucket = MagicMock()
    object_store.upload = MagicMock()
    object_store.download = MagicMock(return_value=(b"file content", {"some": "metadata"}))
    return object_store


@pytest.fixture
def evidence_config():
    """Create a vulnerability evidence configuration."""
    return VulnerabilityEvidenceConfig(
        evidence_bucket="test-audit-bucket",
        storage_prefix="test-vuln-evidence/",
    )


@pytest.fixture
def evidence_service(mock_db_session, mock_object_store, evidence_config):
    """Create a vulnerability evidence service with mocked dependencies."""
    return VulnerabilityEvidenceService(
        session=mock_db_session,
        object_store=mock_object_store,
        config=evidence_config,
    )


# -----------------------------------------------------------------------------
# VulnerabilityEvidenceConfig Tests
# -----------------------------------------------------------------------------


class TestVulnerabilityEvidenceConfig:
    """Tests for VulnerabilityEvidenceConfig dataclass."""

    def test_default_config_values(self):
        """Test that default config has sensible values."""
        config = VulnerabilityEvidenceConfig()
        assert config.evidence_bucket == "qerds-audit"
        assert config.storage_prefix == "vulnerability-evidence/"

    def test_custom_config_values(self, evidence_config):
        """Test that custom config values are applied."""
        assert evidence_config.evidence_bucket == "test-audit-bucket"
        assert evidence_config.storage_prefix == "test-vuln-evidence/"


# -----------------------------------------------------------------------------
# VulnScanMetadata Tests
# -----------------------------------------------------------------------------


class TestVulnScanMetadata:
    """Tests for VulnScanMetadata dataclass."""

    def test_default_values(self):
        """Test VulnScanMetadata with minimal required fields."""
        metadata = VulnScanMetadata(scan_tool="trivy")
        assert metadata.scan_tool == "trivy"
        assert metadata.scan_tool_version is None
        assert metadata.scan_output_format == ScanOutputFormat.TRIVY_JSON
        assert metadata.trivy_db_digest is None
        assert metadata.trivy_db_tag is None
        assert metadata.scan_scope is None

    def test_full_metadata(self):
        """Test VulnScanMetadata with all fields."""
        metadata = VulnScanMetadata(
            scan_tool="trivy",
            scan_tool_version="0.50.0",
            scan_output_format=ScanOutputFormat.SARIF,
            trivy_db_digest="sha256:abc123",
            trivy_db_tag="v2-2024-01-15",
            scan_scope={"images": ["qerds-api:latest"]},
        )
        assert metadata.scan_tool == "trivy"
        assert metadata.scan_tool_version == "0.50.0"
        assert metadata.scan_output_format == ScanOutputFormat.SARIF
        assert metadata.trivy_db_digest == "sha256:abc123"


# -----------------------------------------------------------------------------
# PentestMetadata Tests
# -----------------------------------------------------------------------------


class TestPentestMetadata:
    """Tests for PentestMetadata dataclass."""

    def test_required_fields(self):
        """Test PentestMetadata with required fields."""
        now = datetime.now(UTC)
        end = now + timedelta(days=14)
        metadata = PentestMetadata(
            pentest_firm="SecureTech",
            start_date=now,
            end_date=end,
        )
        assert metadata.pentest_firm == "SecureTech"
        assert metadata.start_date == now
        assert metadata.end_date == end
        assert metadata.methodology is None

    def test_full_metadata(self):
        """Test PentestMetadata with all fields."""
        now = datetime.now(UTC)
        end = now + timedelta(days=14)
        metadata = PentestMetadata(
            pentest_firm="SecureTech",
            start_date=now,
            end_date=end,
            methodology="OWASP Testing Guide v4",
        )
        assert metadata.methodology == "OWASP Testing Guide v4"


# -----------------------------------------------------------------------------
# Store Vulnerability Scan Tests
# -----------------------------------------------------------------------------


class TestStoreVulnScan:
    """Tests for storing vulnerability scan reports."""

    @pytest.mark.asyncio
    async def test_store_vuln_scan_basic(
        self, evidence_service, mock_db_session, mock_object_store
    ):
        """Test basic vulnerability scan storage."""
        scan_data = b'{"vulnerabilities": []}'
        scan_metadata = VulnScanMetadata(scan_tool="trivy")

        result = await evidence_service.store_vuln_scan(
            data=scan_data,
            title="Q1 2024 Container Scan",
            uploaded_by="admin-123",
            reporting_period="2024-Q1",
            scan_metadata=scan_metadata,
        )

        # Verify database record was added
        mock_db_session.add.assert_called_once()
        mock_db_session.flush.assert_called_once()

        # Verify object store was called
        mock_object_store.ensure_bucket.assert_called_once_with("test-audit-bucket")
        mock_object_store.upload.assert_called_once()

        # Verify upload parameters
        upload_call = mock_object_store.upload.call_args
        assert upload_call.kwargs["bucket"] == "test-audit-bucket"
        assert "test-vuln-evidence/vuln_scan/" in upload_call.kwargs["key"]
        assert upload_call.kwargs["data"] == scan_data
        assert upload_call.kwargs["content_type"] == "application/json"

        # Verify result
        assert result.artifact_type == VulnArtifactType.VULN_SCAN
        assert result.title == "Q1 2024 Container Scan"
        assert result.uploaded_by == "admin-123"
        assert result.reporting_period == "2024-Q1"
        assert result.scan_tool == "trivy"
        assert result.include_in_audit_pack is True

    @pytest.mark.asyncio
    async def test_store_vuln_scan_with_trivy_db_tracking(self, evidence_service, mock_db_session):
        """Test vulnerability scan with Trivy air-gap metadata."""
        scan_data = b'{"vulnerabilities": []}'
        scan_metadata = VulnScanMetadata(
            scan_tool="trivy",
            scan_tool_version="0.50.0",
            trivy_db_digest="sha256:abc123def456",
            trivy_db_tag="v2-2024-01-15",
        )

        result = await evidence_service.store_vuln_scan(
            data=scan_data,
            title="Q1 2024 Container Scan",
            uploaded_by="admin-123",
            reporting_period="2024-Q1",
            scan_metadata=scan_metadata,
        )

        assert result.trivy_db_digest == "sha256:abc123def456"
        assert result.trivy_db_tag == "v2-2024-01-15"

    @pytest.mark.asyncio
    async def test_store_vuln_scan_with_findings_summary(self, evidence_service, mock_db_session):
        """Test vulnerability scan with findings summary."""
        scan_data = b'{"vulnerabilities": []}'
        scan_metadata = VulnScanMetadata(scan_tool="trivy")
        findings_summary = {
            "critical": 0,
            "high": 2,
            "medium": 5,
            "low": 10,
            "total": 17,
        }

        result = await evidence_service.store_vuln_scan(
            data=scan_data,
            title="Q1 2024 Container Scan",
            uploaded_by="admin-123",
            reporting_period="2024-Q1",
            scan_metadata=scan_metadata,
            findings_summary=findings_summary,
        )

        assert result.findings_summary == findings_summary

    @pytest.mark.asyncio
    async def test_store_vuln_scan_computes_hash(self, evidence_service, mock_db_session):
        """Test that content hash is computed correctly."""
        scan_data = b'{"vulnerabilities": []}'
        scan_metadata = VulnScanMetadata(scan_tool="trivy")

        result = await evidence_service.store_vuln_scan(
            data=scan_data,
            title="Q1 2024 Container Scan",
            uploaded_by="admin-123",
            reporting_period="2024-Q1",
            scan_metadata=scan_metadata,
        )

        # Verify hash is SHA-256
        import hashlib

        expected_hash = hashlib.sha256(scan_data).hexdigest()
        assert result.content_hash == expected_hash
        assert len(result.content_hash) == 64  # SHA-256 hex digest length


# -----------------------------------------------------------------------------
# Store SBOM Tests
# -----------------------------------------------------------------------------


class TestStoreSBOM:
    """Tests for storing Software Bill of Materials."""

    @pytest.mark.asyncio
    async def test_store_sbom_cyclonedx(self, evidence_service, mock_db_session, mock_object_store):
        """Test storing CycloneDX SBOM."""
        sbom_data = b'{"bomFormat": "CycloneDX"}'

        result = await evidence_service.store_sbom(
            data=sbom_data,
            title="QERDS API SBOM v1.0.0",
            uploaded_by="admin-123",
            sbom_format=SBOMFormat.CYCLONEDX_JSON,
        )

        mock_db_session.add.assert_called_once()
        mock_object_store.upload.assert_called_once()

        assert result.artifact_type == VulnArtifactType.SBOM
        assert result.sbom_format == SBOMFormat.CYCLONEDX_JSON
        assert result.title == "QERDS API SBOM v1.0.0"

    @pytest.mark.asyncio
    async def test_store_sbom_spdx(self, evidence_service, mock_db_session):
        """Test storing SPDX SBOM."""
        sbom_data = b'{"spdxVersion": "SPDX-2.3"}'

        result = await evidence_service.store_sbom(
            data=sbom_data,
            title="QERDS API SBOM SPDX",
            uploaded_by="admin-123",
            sbom_format=SBOMFormat.SPDX_JSON,
        )

        assert result.sbom_format == SBOMFormat.SPDX_JSON

    @pytest.mark.asyncio
    async def test_store_sbom_with_reporting_period(self, evidence_service, mock_db_session):
        """Test SBOM storage with quarterly reporting period."""
        sbom_data = b'{"bomFormat": "CycloneDX"}'

        result = await evidence_service.store_sbom(
            data=sbom_data,
            title="QERDS API SBOM Q1 2024",
            uploaded_by="admin-123",
            sbom_format=SBOMFormat.CYCLONEDX_JSON,
            reporting_period="2024-Q1",
        )

        assert result.reporting_period == "2024-Q1"


# -----------------------------------------------------------------------------
# Store Pentest Report Tests
# -----------------------------------------------------------------------------


class TestStorePentestReport:
    """Tests for storing penetration test reports."""

    @pytest.mark.asyncio
    async def test_store_pentest_report_basic(
        self, evidence_service, mock_db_session, mock_object_store
    ):
        """Test basic pentest report storage."""
        report_data = b"%PDF-1.4 pentest report content"
        now = datetime.now(UTC)
        pentest_metadata = PentestMetadata(
            pentest_firm="SecureTech Inc.",
            start_date=now - timedelta(days=14),
            end_date=now - timedelta(days=1),
        )

        result = await evidence_service.store_pentest_report(
            data=report_data,
            title="Annual Pentest 2024",
            uploaded_by="admin-123",
            pentest_metadata=pentest_metadata,
        )

        mock_db_session.add.assert_called_once()
        mock_object_store.upload.assert_called_once()

        # Verify upload content type
        upload_call = mock_object_store.upload.call_args
        assert upload_call.kwargs["content_type"] == "application/pdf"

        assert result.artifact_type == VulnArtifactType.PENTEST_REPORT
        assert result.pentest_firm == "SecureTech Inc."
        assert result.pentest_start_date == now - timedelta(days=14)
        assert result.pentest_end_date == now - timedelta(days=1)

    @pytest.mark.asyncio
    async def test_store_pentest_report_with_methodology(self, evidence_service, mock_db_session):
        """Test pentest report storage with methodology."""
        report_data = b"%PDF-1.4 pentest report content"
        now = datetime.now(UTC)
        pentest_metadata = PentestMetadata(
            pentest_firm="SecureTech Inc.",
            start_date=now - timedelta(days=14),
            end_date=now - timedelta(days=1),
            methodology="OWASP Testing Guide v4.2",
        )

        result = await evidence_service.store_pentest_report(
            data=report_data,
            title="Annual Pentest 2024",
            uploaded_by="admin-123",
            pentest_metadata=pentest_metadata,
        )

        assert result.pentest_methodology == "OWASP Testing Guide v4.2"

    @pytest.mark.asyncio
    async def test_store_pentest_report_derives_reporting_period(
        self, evidence_service, mock_db_session
    ):
        """Test that reporting period is derived from pentest end date."""
        report_data = b"%PDF-1.4 pentest report content"
        end_date = datetime(2024, 3, 15, tzinfo=UTC)
        pentest_metadata = PentestMetadata(
            pentest_firm="SecureTech Inc.",
            start_date=datetime(2024, 3, 1, tzinfo=UTC),
            end_date=end_date,
        )

        result = await evidence_service.store_pentest_report(
            data=report_data,
            title="Annual Pentest 2024",
            uploaded_by="admin-123",
            pentest_metadata=pentest_metadata,
        )

        # Reporting period should be derived from end_date year
        assert result.reporting_period == "2024"


# -----------------------------------------------------------------------------
# Store Remediation Artifact Tests
# -----------------------------------------------------------------------------


class TestStoreRemediationArtifact:
    """Tests for storing remediation tracking artifacts."""

    @pytest.mark.asyncio
    async def test_store_remediation_plan(
        self, evidence_service, mock_db_session, mock_object_store
    ):
        """Test storing a remediation plan."""
        plan_data = b"%PDF-1.4 remediation plan"

        result = await evidence_service.store_remediation_artifact(
            data=plan_data,
            title="Q1 2024 Remediation Plan",
            uploaded_by="admin-123",
            artifact_type=VulnArtifactType.REMEDIATION_PLAN,
            remediation_status="open",
            remediation_due_date=datetime(2024, 6, 30, tzinfo=UTC),
        )

        assert result.artifact_type == VulnArtifactType.REMEDIATION_PLAN
        assert result.remediation_status == "open"
        assert result.remediation_due_date == datetime(2024, 6, 30, tzinfo=UTC)

    @pytest.mark.asyncio
    async def test_store_remediation_evidence(self, evidence_service, mock_db_session):
        """Test storing remediation completion evidence."""
        evidence_data = b"%PDF-1.4 remediation evidence"
        parent_id = uuid.uuid4()

        result = await evidence_service.store_remediation_artifact(
            data=evidence_data,
            title="CVE-2024-1234 Fix Evidence",
            uploaded_by="admin-123",
            artifact_type=VulnArtifactType.REMEDIATION_EVIDENCE,
            parent_evidence_id=parent_id,
            remediation_status="closed",
        )

        assert result.artifact_type == VulnArtifactType.REMEDIATION_EVIDENCE
        assert result.parent_evidence_id == parent_id
        assert result.remediation_status == "closed"

    @pytest.mark.asyncio
    async def test_store_exception(self, evidence_service, mock_db_session):
        """Test storing risk acceptance/exception documentation."""
        exception_data = b"%PDF-1.4 risk acceptance"

        result = await evidence_service.store_remediation_artifact(
            data=exception_data,
            title="Low-Risk Finding Exception",
            uploaded_by="admin-123",
            artifact_type=VulnArtifactType.EXCEPTION,
            remediation_status="excepted",
        )

        assert result.artifact_type == VulnArtifactType.EXCEPTION
        assert result.remediation_status == "excepted"

    @pytest.mark.asyncio
    async def test_store_remediation_invalid_type_raises(self, evidence_service, mock_db_session):
        """Test that invalid artifact types raise InvalidArtifactError."""
        plan_data = b"%PDF-1.4 data"

        with pytest.raises(InvalidArtifactError) as exc_info:
            await evidence_service.store_remediation_artifact(
                data=plan_data,
                title="Invalid Type",
                uploaded_by="admin-123",
                artifact_type=VulnArtifactType.VULN_SCAN,  # Invalid for remediation
            )

        assert "Invalid artifact type" in str(exc_info.value)


# -----------------------------------------------------------------------------
# Get Artifact Tests
# -----------------------------------------------------------------------------


class TestGetArtifact:
    """Tests for retrieving vulnerability evidence artifacts."""

    @pytest.mark.asyncio
    async def test_get_artifact_found(self, evidence_service, mock_db_session):
        """Test getting an existing artifact."""
        artifact_id = uuid.uuid4()
        mock_evidence = MagicMock()
        mock_evidence.vuln_evidence_id = artifact_id

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_evidence
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        result = await evidence_service.get_artifact(artifact_id)

        assert result == mock_evidence
        mock_db_session.execute.assert_called_once()

    @pytest.mark.asyncio
    async def test_get_artifact_not_found(self, evidence_service, mock_db_session):
        """Test getting a non-existent artifact returns None."""
        artifact_id = uuid.uuid4()

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = None
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        result = await evidence_service.get_artifact(artifact_id)

        assert result is None


# -----------------------------------------------------------------------------
# List Artifacts Tests
# -----------------------------------------------------------------------------


class TestListArtifacts:
    """Tests for listing vulnerability evidence artifacts."""

    @pytest.mark.asyncio
    async def test_list_artifacts_no_filter(self, evidence_service, mock_db_session):
        """Test listing all artifacts without filters."""
        mock_artifacts = [MagicMock(), MagicMock()]
        mock_result = MagicMock()
        mock_result.scalars.return_value.all.return_value = mock_artifacts
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        results = await evidence_service.list_artifacts()

        assert len(results) == 2
        mock_db_session.execute.assert_called_once()

    @pytest.mark.asyncio
    async def test_list_artifacts_by_type(self, evidence_service, mock_db_session):
        """Test filtering artifacts by type."""
        mock_artifacts = [MagicMock()]
        mock_result = MagicMock()
        mock_result.scalars.return_value.all.return_value = mock_artifacts
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        results = await evidence_service.list_artifacts(artifact_type=VulnArtifactType.VULN_SCAN)

        assert len(results) == 1

    @pytest.mark.asyncio
    async def test_list_artifacts_by_period(self, evidence_service, mock_db_session):
        """Test filtering artifacts by reporting period."""
        mock_artifacts = [MagicMock()]
        mock_result = MagicMock()
        mock_result.scalars.return_value.all.return_value = mock_artifacts
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        results = await evidence_service.list_artifacts(reporting_period="2024-Q1")

        assert len(results) == 1

    @pytest.mark.asyncio
    async def test_list_artifacts_for_audit_pack(self, evidence_service, mock_db_session):
        """Test filtering artifacts for audit pack inclusion."""
        mock_artifacts = [MagicMock(), MagicMock()]
        mock_result = MagicMock()
        mock_result.scalars.return_value.all.return_value = mock_artifacts
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        results = await evidence_service.list_artifacts(include_in_audit_pack=True)

        assert len(results) == 2

    @pytest.mark.asyncio
    async def test_list_artifacts_pagination(self, evidence_service, mock_db_session):
        """Test artifact listing with pagination."""
        mock_artifacts = [MagicMock()]
        mock_result = MagicMock()
        mock_result.scalars.return_value.all.return_value = mock_artifacts
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        results = await evidence_service.list_artifacts(limit=10, offset=20)

        assert len(results) == 1


# -----------------------------------------------------------------------------
# Get Artifacts for Audit Pack Tests
# -----------------------------------------------------------------------------


class TestGetArtifactsForAuditPack:
    """Tests for getting artifacts for audit pack export."""

    @pytest.mark.asyncio
    async def test_get_artifacts_for_audit_pack(self, evidence_service, mock_db_session):
        """Test getting artifacts within date range for audit pack."""
        mock_artifacts = [MagicMock(), MagicMock()]
        mock_result = MagicMock()
        mock_result.scalars.return_value.all.return_value = mock_artifacts
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        start_date = datetime(2024, 1, 1, tzinfo=UTC)
        end_date = datetime(2024, 3, 31, tzinfo=UTC)

        results = await evidence_service.get_artifacts_for_audit_pack(
            start_date=start_date,
            end_date=end_date,
        )

        assert len(results) == 2


# -----------------------------------------------------------------------------
# Update Remediation Status Tests
# -----------------------------------------------------------------------------


class TestUpdateRemediationStatus:
    """Tests for updating remediation status."""

    @pytest.mark.asyncio
    async def test_update_status_found(self, evidence_service, mock_db_session):
        """Test updating status of existing artifact."""
        artifact_id = uuid.uuid4()
        mock_evidence = MagicMock()
        mock_evidence.remediation_status = "open"
        mock_evidence.remediation_completed_at = None

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_evidence
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        result = await evidence_service.update_remediation_status(
            artifact_id,
            status="in_progress",
        )

        assert result.remediation_status == "in_progress"
        mock_db_session.flush.assert_called_once()

    @pytest.mark.asyncio
    async def test_update_status_closed_sets_completion_time(
        self, evidence_service, mock_db_session
    ):
        """Test that closing status auto-sets completion timestamp."""
        artifact_id = uuid.uuid4()
        mock_evidence = MagicMock()
        mock_evidence.remediation_status = "in_progress"
        mock_evidence.remediation_completed_at = None

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_evidence
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        result = await evidence_service.update_remediation_status(
            artifact_id,
            status="closed",
        )

        assert result.remediation_status == "closed"
        assert result.remediation_completed_at is not None

    @pytest.mark.asyncio
    async def test_update_status_with_explicit_completion_time(
        self, evidence_service, mock_db_session
    ):
        """Test updating status with explicit completion timestamp."""
        artifact_id = uuid.uuid4()
        mock_evidence = MagicMock()
        mock_evidence.remediation_status = "in_progress"
        mock_evidence.remediation_completed_at = None

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_evidence
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        completed_at = datetime(2024, 3, 15, 10, 30, tzinfo=UTC)
        result = await evidence_service.update_remediation_status(
            artifact_id,
            status="closed",
            completed_at=completed_at,
        )

        assert result.remediation_completed_at == completed_at

    @pytest.mark.asyncio
    async def test_update_status_not_found_raises(self, evidence_service, mock_db_session):
        """Test that updating non-existent artifact raises error."""
        artifact_id = uuid.uuid4()

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = None
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        with pytest.raises(ArtifactNotFoundError) as exc_info:
            await evidence_service.update_remediation_status(
                artifact_id,
                status="closed",
            )

        assert str(artifact_id) in str(exc_info.value)


# -----------------------------------------------------------------------------
# Download Artifact Tests
# -----------------------------------------------------------------------------


class TestDownloadArtifact:
    """Tests for downloading artifact content."""

    @pytest.mark.asyncio
    async def test_download_artifact_found(
        self, evidence_service, mock_db_session, mock_object_store
    ):
        """Test downloading existing artifact content."""
        artifact_id = uuid.uuid4()
        mock_evidence = MagicMock()
        mock_evidence.vuln_evidence_id = artifact_id
        mock_evidence.storage_ref = "s3://test-bucket/test-key"
        mock_evidence.content_hash = "abc123"

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = mock_evidence
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        mock_object_store.download.return_value = (b"file content", {"some": "meta"})

        data, evidence = await evidence_service.download_artifact(artifact_id)

        assert data == b"file content"
        assert evidence == mock_evidence
        mock_object_store.download.assert_called_once_with(
            bucket="test-bucket",
            key="test-key",
            expected_digest="abc123",
        )

    @pytest.mark.asyncio
    async def test_download_artifact_not_found_raises(self, evidence_service, mock_db_session):
        """Test that downloading non-existent artifact raises error."""
        artifact_id = uuid.uuid4()

        mock_result = MagicMock()
        mock_result.scalar_one_or_none.return_value = None
        mock_db_session.execute = AsyncMock(return_value=mock_result)

        with pytest.raises(ArtifactNotFoundError) as exc_info:
            await evidence_service.download_artifact(artifact_id)

        assert str(artifact_id) in str(exc_info.value)


# -----------------------------------------------------------------------------
# Storage Key Building Tests
# -----------------------------------------------------------------------------


class TestStorageKeyBuilding:
    """Tests for storage key construction."""

    def test_build_storage_key_vuln_scan(self, evidence_service):
        """Test storage key format for vulnerability scans."""
        artifact_id = uuid.uuid4()
        key = evidence_service._build_storage_key(VulnArtifactType.VULN_SCAN, artifact_id)
        assert key.startswith("test-vuln-evidence/vuln_scan/")
        assert str(artifact_id) in key

    def test_build_storage_key_sbom(self, evidence_service):
        """Test storage key format for SBOMs."""
        artifact_id = uuid.uuid4()
        key = evidence_service._build_storage_key(VulnArtifactType.SBOM, artifact_id)
        assert key.startswith("test-vuln-evidence/sbom/")

    def test_build_storage_key_pentest(self, evidence_service):
        """Test storage key format for pentest reports."""
        artifact_id = uuid.uuid4()
        key = evidence_service._build_storage_key(VulnArtifactType.PENTEST_REPORT, artifact_id)
        assert key.startswith("test-vuln-evidence/pentest_report/")


# -----------------------------------------------------------------------------
# Hash Computation Tests
# -----------------------------------------------------------------------------


class TestHashComputation:
    """Tests for content hash computation."""

    def test_compute_hash_sha256(self, evidence_service):
        """Test that hash is computed as SHA-256."""
        data = b"test content for hashing"
        computed_hash = evidence_service._compute_hash(data)

        import hashlib

        expected_hash = hashlib.sha256(data).hexdigest()
        assert computed_hash == expected_hash

    def test_compute_hash_empty_content(self, evidence_service):
        """Test hash computation for empty content."""
        computed_hash = evidence_service._compute_hash(b"")

        import hashlib

        expected_hash = hashlib.sha256(b"").hexdigest()
        assert computed_hash == expected_hash


# -----------------------------------------------------------------------------
# Factory Function Tests
# -----------------------------------------------------------------------------


class TestCreateVulnerabilityEvidenceService:
    """Tests for the factory function."""

    @pytest.mark.asyncio
    async def test_create_service_with_defaults(self, mock_db_session, mock_object_store):
        """Test creating service via factory function with defaults."""
        service = await create_vulnerability_evidence_service(
            session=mock_db_session,
            object_store=mock_object_store,
        )

        assert isinstance(service, VulnerabilityEvidenceService)
        assert service._config.evidence_bucket == "qerds-audit"
        assert service._config.storage_prefix == "vulnerability-evidence/"

    @pytest.mark.asyncio
    async def test_create_service_with_custom_config(self, mock_db_session, mock_object_store):
        """Test creating service via factory function with custom config."""
        service = await create_vulnerability_evidence_service(
            session=mock_db_session,
            object_store=mock_object_store,
            evidence_bucket="custom-bucket",
            storage_prefix="custom-prefix/",
        )

        assert isinstance(service, VulnerabilityEvidenceService)
        assert service._config.evidence_bucket == "custom-bucket"
        assert service._config.storage_prefix == "custom-prefix/"
