"""Vulnerability evidence management service.

Covers: REQ-D05 (vulnerability scanning), REQ-D06 (penetration testing),
        REQ-H09 (vulnerability management evidence)

This module provides services for storing and managing vulnerability
management artifacts suitable for audits:

- Quarterly vulnerability scan reports (REQ-D05)
- Annual penetration test reports (REQ-D06)
- SBOMs (Software Bill of Materials)
- Remediation tracking artifacts

All artifacts are stored in object storage with metadata in PostgreSQL.
The service supports the Trivy air-gap/controlled-update approach for
self-hosted vulnerability scanning.
"""

from __future__ import annotations

import hashlib
import logging
import uuid
from dataclasses import dataclass
from datetime import UTC, datetime
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from sqlalchemy.ext.asyncio import AsyncSession

    from qerds.services.storage import ObjectStoreClient

from qerds.db.models.audit import (
    SBOMFormat,
    ScanOutputFormat,
    VulnArtifactType,
    VulnerabilityEvidence,
)

logger = logging.getLogger(__name__)


class VulnerabilityEvidenceError(Exception):
    """Base exception for vulnerability evidence operations."""


class ArtifactNotFoundError(VulnerabilityEvidenceError):
    """Raised when a requested artifact does not exist."""


class InvalidArtifactError(VulnerabilityEvidenceError):
    """Raised when artifact data is invalid or malformed."""


@dataclass(frozen=True, slots=True)
class VulnArtifactSummary:
    """Summary of a vulnerability evidence artifact.

    Attributes:
        vuln_evidence_id: Unique identifier.
        artifact_type: Type of artifact.
        title: Human-readable title.
        created_at: Upload timestamp.
        uploaded_by: ID of admin who uploaded.
        reporting_period: Quarterly reporting period if applicable.
        storage_ref: Object storage reference.
        content_hash: SHA-256 hash of content.
        size_bytes: File size.
        findings_summary: Parsed findings summary if available.
    """

    vuln_evidence_id: uuid.UUID
    artifact_type: str
    title: str
    created_at: datetime
    uploaded_by: str
    reporting_period: str | None
    storage_ref: str
    content_hash: str
    size_bytes: int
    findings_summary: dict[str, Any] | None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for API responses."""
        return {
            "vuln_evidence_id": str(self.vuln_evidence_id),
            "artifact_type": self.artifact_type,
            "title": self.title,
            "created_at": self.created_at.isoformat(),
            "uploaded_by": self.uploaded_by,
            "reporting_period": self.reporting_period,
            "storage_ref": self.storage_ref,
            "content_hash": self.content_hash,
            "size_bytes": self.size_bytes,
            "findings_summary": self.findings_summary,
        }


@dataclass(frozen=True, slots=True)
class VulnScanMetadata:
    """Metadata specific to vulnerability scans.

    Attributes:
        scan_tool: Tool used (e.g., "trivy").
        scan_tool_version: Version of the scanning tool.
        scan_output_format: Output format (trivy_json, sarif, cyclonedx).
        trivy_db_digest: Trivy vulnerability DB digest for air-gap tracking.
        trivy_db_tag: Trivy vulnerability DB tag/version.
        scan_scope: Scope of what was scanned (images, repos, etc.).
    """

    scan_tool: str
    scan_tool_version: str | None = None
    scan_output_format: ScanOutputFormat = ScanOutputFormat.TRIVY_JSON
    trivy_db_digest: str | None = None
    trivy_db_tag: str | None = None
    scan_scope: dict[str, Any] | None = None


@dataclass(frozen=True, slots=True)
class PentestMetadata:
    """Metadata specific to penetration test reports.

    Attributes:
        pentest_firm: Name of the firm that conducted the test.
        start_date: Start date of testing engagement.
        end_date: End date of testing engagement.
        methodology: Testing methodology used (e.g., OWASP, PTES).
    """

    pentest_firm: str
    start_date: datetime
    end_date: datetime
    methodology: str | None = None


@dataclass
class VulnerabilityEvidenceConfig:
    """Configuration for vulnerability evidence storage.

    Attributes:
        evidence_bucket: S3 bucket for vulnerability evidence.
        storage_prefix: Key prefix for evidence objects.
    """

    evidence_bucket: str = "qerds-audit"
    storage_prefix: str = "vulnerability-evidence/"


class VulnerabilityEvidenceService:
    """Service for managing vulnerability management evidence.

    Provides CRUD operations for vulnerability scan reports, SBOMs,
    penetration test reports, and remediation tracking artifacts.

    Example:
        service = VulnerabilityEvidenceService(db_session, object_store)
        artifact = await service.store_vuln_scan(
            data=scan_output_bytes,
            title="Q1 2024 Container Scan",
            uploaded_by="admin-123",
            reporting_period="2024-Q1",
            scan_metadata=VulnScanMetadata(
                scan_tool="trivy",
                scan_tool_version="0.50.0",
                trivy_db_digest="sha256:abc123...",
            ),
        )
    """

    def __init__(
        self,
        session: AsyncSession,
        object_store: ObjectStoreClient,
        config: VulnerabilityEvidenceConfig | None = None,
    ) -> None:
        """Initialize the vulnerability evidence service.

        Args:
            session: Database session for storing metadata.
            object_store: Object store client for artifact storage.
            config: Optional configuration (uses defaults if None).
        """
        self._session = session
        self._object_store = object_store
        self._config = config or VulnerabilityEvidenceConfig()

    def _compute_hash(self, data: bytes) -> str:
        """Compute SHA-256 hash of data."""
        return hashlib.sha256(data).hexdigest()

    def _build_storage_key(self, artifact_type: VulnArtifactType, artifact_id: uuid.UUID) -> str:
        """Build storage key for an artifact."""
        return f"{self._config.storage_prefix}{artifact_type.value}/{artifact_id}"

    async def store_vuln_scan(
        self,
        *,
        data: bytes,
        title: str,
        uploaded_by: str,
        reporting_period: str,
        scan_metadata: VulnScanMetadata,
        content_type: str = "application/json",
        original_filename: str | None = None,
        description: str | None = None,
        findings_summary: dict[str, Any] | None = None,
    ) -> VulnerabilityEvidence:
        """Store a vulnerability scan report.

        Args:
            data: Raw scan output bytes.
            title: Human-readable title for the artifact.
            uploaded_by: ID of the admin uploading the artifact.
            reporting_period: Quarterly period (e.g., "2024-Q1").
            scan_metadata: Scan-specific metadata.
            content_type: MIME type of the content.
            original_filename: Original filename if available.
            description: Optional description.
            findings_summary: Parsed findings summary.

        Returns:
            Created VulnerabilityEvidence record.
        """
        artifact_id = uuid.uuid4()
        content_hash = self._compute_hash(data)
        storage_key = self._build_storage_key(VulnArtifactType.VULN_SCAN, artifact_id)

        # Store to object storage
        self._object_store.ensure_bucket(self._config.evidence_bucket)
        self._object_store.upload(
            bucket=self._config.evidence_bucket,
            key=storage_key,
            data=data,
            content_type=content_type,
            metadata={
                "artifact-id": str(artifact_id),
                "artifact-type": VulnArtifactType.VULN_SCAN.value,
                "reporting-period": reporting_period,
                "scan-tool": scan_metadata.scan_tool,
            },
        )

        storage_ref = f"s3://{self._config.evidence_bucket}/{storage_key}"

        # Create database record
        evidence = VulnerabilityEvidence(
            vuln_evidence_id=artifact_id,
            artifact_type=VulnArtifactType.VULN_SCAN,
            title=title,
            description=description,
            storage_ref=storage_ref,
            content_hash=content_hash,
            content_type=content_type,
            size_bytes=len(data),
            original_filename=original_filename,
            uploaded_by=uploaded_by,
            scan_tool=scan_metadata.scan_tool,
            scan_tool_version=scan_metadata.scan_tool_version,
            scan_output_format=scan_metadata.scan_output_format,
            trivy_db_digest=scan_metadata.trivy_db_digest,
            trivy_db_tag=scan_metadata.trivy_db_tag,
            scan_scope=scan_metadata.scan_scope,
            reporting_period=reporting_period,
            findings_summary=findings_summary,
            include_in_audit_pack=True,
        )

        self._session.add(evidence)
        await self._session.flush()

        logger.info(
            "Stored vulnerability scan: id=%s, period=%s, tool=%s",
            artifact_id,
            reporting_period,
            scan_metadata.scan_tool,
        )

        return evidence

    async def store_sbom(
        self,
        *,
        data: bytes,
        title: str,
        uploaded_by: str,
        sbom_format: SBOMFormat,
        content_type: str = "application/json",
        original_filename: str | None = None,
        description: str | None = None,
        reporting_period: str | None = None,
        metadata: dict[str, Any] | None = None,
    ) -> VulnerabilityEvidence:
        """Store a Software Bill of Materials (SBOM).

        Args:
            data: Raw SBOM bytes.
            title: Human-readable title.
            uploaded_by: ID of the admin uploading.
            sbom_format: SBOM format (CycloneDX, SPDX).
            content_type: MIME type.
            original_filename: Original filename.
            description: Optional description.
            reporting_period: Quarterly period if tied to a scan.
            metadata: Additional metadata.

        Returns:
            Created VulnerabilityEvidence record.
        """
        artifact_id = uuid.uuid4()
        content_hash = self._compute_hash(data)
        storage_key = self._build_storage_key(VulnArtifactType.SBOM, artifact_id)

        self._object_store.ensure_bucket(self._config.evidence_bucket)
        self._object_store.upload(
            bucket=self._config.evidence_bucket,
            key=storage_key,
            data=data,
            content_type=content_type,
            metadata={
                "artifact-id": str(artifact_id),
                "artifact-type": VulnArtifactType.SBOM.value,
                "sbom-format": sbom_format.value,
            },
        )

        storage_ref = f"s3://{self._config.evidence_bucket}/{storage_key}"

        evidence = VulnerabilityEvidence(
            vuln_evidence_id=artifact_id,
            artifact_type=VulnArtifactType.SBOM,
            title=title,
            description=description,
            storage_ref=storage_ref,
            content_hash=content_hash,
            content_type=content_type,
            size_bytes=len(data),
            original_filename=original_filename,
            uploaded_by=uploaded_by,
            sbom_format=sbom_format,
            reporting_period=reporting_period,
            extra_metadata=metadata,
            include_in_audit_pack=True,
        )

        self._session.add(evidence)
        await self._session.flush()

        logger.info("Stored SBOM: id=%s, format=%s", artifact_id, sbom_format.value)

        return evidence

    async def store_pentest_report(
        self,
        *,
        data: bytes,
        title: str,
        uploaded_by: str,
        pentest_metadata: PentestMetadata,
        content_type: str = "application/pdf",
        original_filename: str | None = None,
        description: str | None = None,
        findings_summary: dict[str, Any] | None = None,
    ) -> VulnerabilityEvidence:
        """Store a penetration test report.

        Args:
            data: Raw report bytes (typically PDF).
            title: Human-readable title.
            uploaded_by: ID of the admin uploading.
            pentest_metadata: Pentest-specific metadata.
            content_type: MIME type.
            original_filename: Original filename.
            description: Optional description.
            findings_summary: Summary of findings.

        Returns:
            Created VulnerabilityEvidence record.
        """
        artifact_id = uuid.uuid4()
        content_hash = self._compute_hash(data)
        storage_key = self._build_storage_key(VulnArtifactType.PENTEST_REPORT, artifact_id)

        self._object_store.ensure_bucket(self._config.evidence_bucket)
        self._object_store.upload(
            bucket=self._config.evidence_bucket,
            key=storage_key,
            data=data,
            content_type=content_type,
            metadata={
                "artifact-id": str(artifact_id),
                "artifact-type": VulnArtifactType.PENTEST_REPORT.value,
                "pentest-firm": pentest_metadata.pentest_firm,
            },
        )

        storage_ref = f"s3://{self._config.evidence_bucket}/{storage_key}"

        # Derive reporting period from pentest dates (year)
        reporting_period = str(pentest_metadata.end_date.year)

        evidence = VulnerabilityEvidence(
            vuln_evidence_id=artifact_id,
            artifact_type=VulnArtifactType.PENTEST_REPORT,
            title=title,
            description=description,
            storage_ref=storage_ref,
            content_hash=content_hash,
            content_type=content_type,
            size_bytes=len(data),
            original_filename=original_filename,
            uploaded_by=uploaded_by,
            pentest_firm=pentest_metadata.pentest_firm,
            pentest_start_date=pentest_metadata.start_date,
            pentest_end_date=pentest_metadata.end_date,
            pentest_methodology=pentest_metadata.methodology,
            reporting_period=reporting_period,
            findings_summary=findings_summary,
            include_in_audit_pack=True,
        )

        self._session.add(evidence)
        await self._session.flush()

        logger.info(
            "Stored pentest report: id=%s, firm=%s, period=%s",
            artifact_id,
            pentest_metadata.pentest_firm,
            reporting_period,
        )

        return evidence

    async def store_remediation_artifact(
        self,
        *,
        data: bytes,
        title: str,
        uploaded_by: str,
        artifact_type: VulnArtifactType,
        parent_evidence_id: uuid.UUID | None = None,
        content_type: str = "application/pdf",
        original_filename: str | None = None,
        description: str | None = None,
        remediation_status: str | None = None,
        remediation_due_date: datetime | None = None,
        metadata: dict[str, Any] | None = None,
    ) -> VulnerabilityEvidence:
        """Store a remediation tracking artifact.

        Args:
            data: Raw artifact bytes.
            title: Human-readable title.
            uploaded_by: ID of the admin uploading.
            artifact_type: Type (remediation_plan, remediation_evidence, exception).
            parent_evidence_id: ID of parent artifact (e.g., the scan/pentest report).
            content_type: MIME type.
            original_filename: Original filename.
            description: Optional description.
            remediation_status: Current status (open, in_progress, closed, excepted).
            remediation_due_date: Due date for remediation.
            metadata: Additional metadata.

        Returns:
            Created VulnerabilityEvidence record.
        """
        valid_types = {
            VulnArtifactType.REMEDIATION_PLAN,
            VulnArtifactType.REMEDIATION_EVIDENCE,
            VulnArtifactType.EXCEPTION,
            VulnArtifactType.PENTEST_SCOPE,
        }
        if artifact_type not in valid_types:
            msg = f"Invalid artifact type for remediation: {artifact_type}"
            raise InvalidArtifactError(msg)

        artifact_id = uuid.uuid4()
        content_hash = self._compute_hash(data)
        storage_key = self._build_storage_key(artifact_type, artifact_id)

        self._object_store.ensure_bucket(self._config.evidence_bucket)
        self._object_store.upload(
            bucket=self._config.evidence_bucket,
            key=storage_key,
            data=data,
            content_type=content_type,
            metadata={
                "artifact-id": str(artifact_id),
                "artifact-type": artifact_type.value,
            },
        )

        storage_ref = f"s3://{self._config.evidence_bucket}/{storage_key}"

        evidence = VulnerabilityEvidence(
            vuln_evidence_id=artifact_id,
            artifact_type=artifact_type,
            title=title,
            description=description,
            storage_ref=storage_ref,
            content_hash=content_hash,
            content_type=content_type,
            size_bytes=len(data),
            original_filename=original_filename,
            uploaded_by=uploaded_by,
            parent_evidence_id=parent_evidence_id,
            remediation_status=remediation_status,
            remediation_due_date=remediation_due_date,
            extra_metadata=metadata,
            include_in_audit_pack=True,
        )

        self._session.add(evidence)
        await self._session.flush()

        logger.info(
            "Stored remediation artifact: id=%s, type=%s, parent=%s",
            artifact_id,
            artifact_type.value,
            parent_evidence_id,
        )

        return evidence

    async def get_artifact(self, artifact_id: uuid.UUID) -> VulnerabilityEvidence | None:
        """Get a vulnerability evidence artifact by ID.

        Args:
            artifact_id: UUID of the artifact.

        Returns:
            VulnerabilityEvidence if found, None otherwise.
        """
        from sqlalchemy import select

        query = select(VulnerabilityEvidence).where(
            VulnerabilityEvidence.vuln_evidence_id == artifact_id
        )
        result = await self._session.execute(query)
        return result.scalar_one_or_none()

    async def list_artifacts(
        self,
        *,
        artifact_type: VulnArtifactType | None = None,
        reporting_period: str | None = None,
        include_in_audit_pack: bool | None = None,
        limit: int = 100,
        offset: int = 0,
    ) -> list[VulnerabilityEvidence]:
        """List vulnerability evidence artifacts with optional filtering.

        Args:
            artifact_type: Filter by artifact type.
            reporting_period: Filter by reporting period.
            include_in_audit_pack: Filter by audit pack inclusion flag.
            limit: Maximum results to return.
            offset: Number of results to skip.

        Returns:
            List of VulnerabilityEvidence records.
        """
        from sqlalchemy import select

        query = select(VulnerabilityEvidence).order_by(VulnerabilityEvidence.created_at.desc())

        if artifact_type is not None:
            query = query.where(VulnerabilityEvidence.artifact_type == artifact_type)
        if reporting_period is not None:
            query = query.where(VulnerabilityEvidence.reporting_period == reporting_period)
        if include_in_audit_pack is not None:
            query = query.where(
                VulnerabilityEvidence.include_in_audit_pack == include_in_audit_pack
            )

        query = query.limit(limit).offset(offset)

        result = await self._session.execute(query)
        return list(result.scalars().all())

    async def get_artifacts_for_audit_pack(
        self,
        start_date: datetime,
        end_date: datetime,
    ) -> list[VulnerabilityEvidence]:
        """Get vulnerability evidence artifacts for inclusion in an audit pack.

        Returns artifacts within the date range that are marked for
        audit pack inclusion.

        Args:
            start_date: Start of date range (inclusive).
            end_date: End of date range (inclusive).

        Returns:
            List of VulnerabilityEvidence records for the pack.
        """
        from sqlalchemy import select

        query = (
            select(VulnerabilityEvidence)
            .where(VulnerabilityEvidence.include_in_audit_pack.is_(True))
            .where(VulnerabilityEvidence.created_at >= start_date)
            .where(VulnerabilityEvidence.created_at <= end_date)
            .order_by(VulnerabilityEvidence.created_at)
        )

        result = await self._session.execute(query)
        return list(result.scalars().all())

    async def update_remediation_status(
        self,
        artifact_id: uuid.UUID,
        *,
        status: str,
        completed_at: datetime | None = None,
    ) -> VulnerabilityEvidence:
        """Update the remediation status of an artifact.

        Args:
            artifact_id: UUID of the artifact.
            status: New remediation status.
            completed_at: Completion timestamp if status is 'closed'.

        Returns:
            Updated VulnerabilityEvidence record.

        Raises:
            ArtifactNotFoundError: If artifact does not exist.
        """
        evidence = await self.get_artifact(artifact_id)
        if evidence is None:
            msg = f"Artifact not found: {artifact_id}"
            raise ArtifactNotFoundError(msg)

        evidence.remediation_status = status
        if completed_at is not None:
            evidence.remediation_completed_at = completed_at
        elif status == "closed" and evidence.remediation_completed_at is None:
            evidence.remediation_completed_at = datetime.now(UTC)

        await self._session.flush()

        logger.info(
            "Updated remediation status: id=%s, status=%s",
            artifact_id,
            status,
        )

        return evidence

    async def download_artifact(
        self, artifact_id: uuid.UUID
    ) -> tuple[bytes, VulnerabilityEvidence]:
        """Download an artifact's content from object storage.

        Args:
            artifact_id: UUID of the artifact.

        Returns:
            Tuple of (content bytes, metadata record).

        Raises:
            ArtifactNotFoundError: If artifact does not exist.
        """
        evidence = await self.get_artifact(artifact_id)
        if evidence is None:
            msg = f"Artifact not found: {artifact_id}"
            raise ArtifactNotFoundError(msg)

        # Parse storage_ref to get bucket and key
        # Format: s3://bucket/key
        storage_ref = evidence.storage_ref
        if storage_ref.startswith("s3://"):
            parts = storage_ref[5:].split("/", 1)
            bucket = parts[0]
            key = parts[1] if len(parts) > 1 else ""
        else:
            bucket = self._config.evidence_bucket
            key = storage_ref

        data, _metadata = self._object_store.download(
            bucket=bucket,
            key=key,
            expected_digest=evidence.content_hash,
        )

        return data, evidence


async def create_vulnerability_evidence_service(
    session: AsyncSession,
    object_store: ObjectStoreClient,
    *,
    evidence_bucket: str = "qerds-audit",
    storage_prefix: str = "vulnerability-evidence/",
) -> VulnerabilityEvidenceService:
    """Factory function to create a VulnerabilityEvidenceService.

    Args:
        session: Database session.
        object_store: Object store client.
        evidence_bucket: S3 bucket for evidence.
        storage_prefix: Key prefix for evidence objects.

    Returns:
        Configured VulnerabilityEvidenceService instance.
    """
    config = VulnerabilityEvidenceConfig(
        evidence_bucket=evidence_bucket,
        storage_prefix=storage_prefix,
    )
    return VulnerabilityEvidenceService(session, object_store, config)
